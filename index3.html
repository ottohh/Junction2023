<!DOCTYPE html>
<html>

<head>
  <title>WebGL Instancing Example</title>
</head>

<body>
  <canvas id="canvas" width="400" height="400"></canvas>



  <script type="module">



    const BALL_COUNT = 1000;

		const render_times = [];
		const physics_times = [];

    const ballStateArray = new Float32Array(new SharedArrayBuffer(BALL_COUNT * 4 * 4));
    const ballStateArrayOut = new Float32Array(new SharedArrayBuffer(BALL_COUNT * 4 * 4));


    const ballRadiusArray = new Float32Array(new SharedArrayBuffer(BALL_COUNT * 4));
    for (let i = 0; i < BALL_COUNT * 4; i++) {
      ballRadiusArray[i] = (Math.random() + 0.0001);
			ballStateArray[i] = (Math.random() + 0.0001) * 2 - 1;
    }

    if (!window.Worker) {
      throw new Error("no worker:(")
    }
    const workerPool = []
    for (let i = 0; i < Math.min(8, BALL_COUNT); i++) {
      const worker = new Worker("worker.js")

      workerPool.push(worker)
    }

    let resolver = undefined
    const waitPromise = (workers) => {
      if (resolver != null) {
        new Error("resolver defined!")
      }
      const promise = new Promise(resolve => resolver = resolve)

      let i = 0
      for (const worker of workers) {
        worker.onmessage = (data) => {
          i++;
          if (i === workers.length) {
            resolver?.()
            resolver = undefined
          }
        }
      }
      return promise
    }


    let steps = 0;




    ////Below is wegGL code





    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl");

    // Vertex shader source code
    const vertexShaderSource = `
        attribute vec2 a_position;
        uniform mat4 u_model;

        void main() {
          gl_Position = u_model * vec4(a_position, 0.0, 1.0);
        }
      `;

    // Fragment shader source code
    const fragmentShaderSource = `
        precision mediump float;
        uniform vec4 u_color;

        void main() {
          gl_FragColor = u_color;
        }
      `;

    // Create shaders
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);

    // Create shader program
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);



    let then = 0;

    var deltaTime = 0;


    async function render(now) {
      now *= 0.001; // convert to seconds
      deltaTime = now - then;
      then = now;


      //updating square positins and count if wanted to 
      const perWorker = Math.floor(BALL_COUNT / workerPool.length)

			const now3 = performance.now()

      for (let i = 0; i < workerPool.length; i++) {
        if (i == workerPool.length - 1) {
          workerPool[i].postMessage({
            start: i * perWorker,
            end: BALL_COUNT,
            dataIn: steps % 2 === 0 ? ballStateArray : ballStateArrayOut,
            dataOut: steps % 2 === 0 ? ballStateArrayOut : ballStateArray,
            ballRadius: ballRadiusArray,
            name: i

          })
        } else {
          workerPool[i].postMessage({
            start: i * perWorker,
            end: (i + 1) * perWorker,
            dataIn: steps % 2 === 0 ? ballStateArray : ballStateArrayOut,
            dataOut: steps % 2 === 0 ? ballStateArrayOut : ballStateArray,
            ballRadius: ballRadiusArray,
            name: i
          })
        }
      }
      await waitPromise(workerPool)
      steps++;

			physics_times.push(performance.now()-now3)
			const now2 = performance.now()




      // Define square vertex data
      const squareVertices = new Float32Array([
        -0.1, -0.1,
        0.1, -0.1,
        0.1, 0.1,
        -0.1, 0.1,
      ]);


      // Create a buffer for square vertices
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, squareVertices, gl.STATIC_DRAW);

      // Define colors for each square
      const squareColors = [
        [1.0, 0.0, 0.0, 1.0],  // Red
        [0.0, 1.0, 0.0, 1.0],  // Green
        [0.0, 0.0, 1.0, 1.0],  // Blue
      ];


      // Set up attribute and uniform locations
      const positionLocation = gl.getAttribLocation(program, "a_position");
      const modelMatrixLocation = gl.getUniformLocation(program, "u_model");
      const colorLocation = gl.getUniformLocation(program, "u_color");

      // Clear the canvas
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);



      for (let i = 0; i < BALL_COUNT; i++) {
        let position = [];
        if(steps%2==0){
          position = [ballStateArrayOut[i*4],ballStateArrayOut[i*4+1]];
        }else{
          position = [ballStateArray[i*4],ballStateArray[i*4+1]];
        }

        const color = squareColors[0];

        const modelMatrix = new Float32Array([
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          position[0], position[1], 0.0, 1.0,
        ]);

        gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
        gl.uniform4fv(colorLocation, color);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);


        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);


      }

      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
			render_times.push(performance.now()-now2)
			if(steps % 120 === 0){
				console.log(`Average time spent in render loop ${render_times.reduce((avg, val) => avg + val/render_times.length, 0)} ms`)
				console.log(`Average time spent in physics loop ${physics_times.reduce((avg, val) => avg + val/physics_times.length, 0)} ms`)
			}
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);


  </script>
</body>

</html>