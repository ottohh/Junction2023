<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
				const adapter = await navigator.gpu?.requestAdapter();
				const device = await adapter?.requestDevice();
				if (!device) {
					throw new Error()
				}

				// Get a WebGPU context from the canvas and configure it
				const canvas = document.querySelector('canvas');
				const context = canvas.getContext('webgpu');
				const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device: device,
					format: canvasFormat,
				})
				const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device,
					format: presentationFormat,
				});
				/*
				const vertices = new Float32Array([
				//   X,    Y,
					-0.8, -0.8, // Triangle 1 (Blue)
					0.8, -0.8,
					0.8,  0.8,

					-0.8, -0.8, // Triangle 2 (Red)
					0.8,  0.8,
					-0.8,  0.8,
				]);*/

				const SECTORS = 10;

				const SUBDIVISIONS = 5;
				
								
				const vertices = new Float32Array([
				//   X,    Y,
					0, 0, // Triangle 1 (Blue)
					1, 1,
					0,  1,

					0, 0, // Triangle 2 (Red)
					1,  0,
					1,  1,
				]);
				/*
				for(let i = 0; i < SUBDIVISIONS; i++){
					vertices[6*i] = 0;
					vertices[6*i+1] = 0;
					vertices[6*i+2] = Math.cos(2*Math.PI/SUBDIVISIONS*i);
					vertices[6*i+3] = Math.sin(2*Math.PI/SUBDIVISIONS*i);
					vertices[6*i+4] = Math.cos(2*Math.PI/SUBDIVISIONS*(i+1));
					vertices[6*i+5] = Math.sin(2*Math.PI/SUBDIVISIONS*(i+1));
				}*/

				const vertexBuffer = device.createBuffer({
				label: "Cell vertices",
				size: vertices.byteLength,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
			});
			device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
				
			const vertexBufferLayout = {
				arrayStride: 8,
				attributes: [{
					format: "float32x2",
					offset: 0,
					shaderLocation: 0, // Position, see vertex shader
				}],
			};
			const cellShaderModule = device.createShaderModule({
					label: 'Cell shader',
					code: `
					struct VertexInput {
					@location(0) pos: vec2f,
					@builtin(instance_index) instance: u32,
					@builtin(vertex_index) vertexIndex : u32
				};
				@group(0) @binding(0) var<storage> angle: array<f32>;

				struct VertexOutput {
					@builtin(position) pos: vec4f,
					@location(0) position: vec2f,
					@location(1) radius: f32,
					@location(2) instance: f32,
				};
				struct FragInput {
					@builtin(position) pos: vec4f,
					@location(0) position: vec2f,
					@location(1) radius: f32,
					@location(2) instance: f32,
				};
						@vertex
						fn vertexMain(input: VertexInput) -> VertexOutput  {
							let pos1 = vec2f(f32(input.instance) % 3 / 3 - 0.2, floor(f32(input.instance) / 3)/1.7-0.5);
							let radius = 0.5;
							let anotherpos = vec2f(input.pos.x*radius - radius / 2, input.pos.y*radius - radius / 2);
							var output: VertexOutput;
							output.pos = vec4f((anotherpos+pos1), 0, 1);
							output.position = pos1;
							output.radius = radius;
							output.instance = f32(input.instance);
							return output;
						}


						@fragment
						fn fragmentMain(input: FragInput) -> @location(0) vec4f {
							let vec = vec2f(input.pos.x/ 512 - 0.5, (input.pos.y / 512 - 0.5)*-1)* 2 - input.position;
							let dist = vec.x*vec.x+vec.y*vec.y;
							if(dist > (input.radius/2)*(input.radius/2)) {
							  discard;
							}
							return vec4f(1, input.instance / 9, input.instance / 9, 1);
						}
					`
				});
				const WORKGROUP_SIZE = 1;

				// Create an array representing the active state of each cell.
			const angle = new Float32Array(1);
			
			angle[0] = 0;

[]			
			// Create a storage buffer to hold the cell state.
			const angleStorage = device.createBuffer({
				label: "Cell State",
				size: angle.byteLength,
				usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
			});
			const angle_out = new Float32Array(1);
			
			angle_out[0] = 0;

			
			// Create a storage buffer to hold the cell state.
			const angleOutStorage = device.createBuffer({
				label: "Cell State",
				size: angle_out.byteLength,
				usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
			});
			device.queue.writeBuffer(angleStorage, 0, angle);
			device.queue.writeBuffer(angleOutStorage, 0, angle_out)
				const simulationShaderModule = device.createShaderModule({
					label: "Game of Life simulation shader",
					code: `
					@group(0) @binding(0) var<storage> angle: array<f32>;
					@group(0) @binding(1) var<storage, read_write> angle_out: array<f32>;
						@compute
						@workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE})
						fn computeMain() {
							angle_out[0] = angle[0]+3.14/100;
						}`
				});


				// Create the bind group layout and pipeline layout.
		const bindGroupLayout = device.createBindGroupLayout({
			label: "Cell Bind Group Layout",
			entries: [{
				binding: 0,
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
			buffer: { type: "read-only-storage"} // Cell state input buffer
			}, {
				binding: 1,
				visibility: GPUShaderStage.COMPUTE,
				buffer: { type: "storage"} // Cell state output buffer
			}]
		});
		const bindGroups = [
  device.createBindGroup({
    label: "Cell renderer bind group A",
    layout: bindGroupLayout, // Updated Line
    entries: [{
      binding: 0,
      resource: { buffer: angleStorage }
    }, {
      binding: 1, // New Entry
      resource: { buffer: angleOutStorage }
    }],
  }),
  device.createBindGroup({
    label: "Cell renderer bind group B",
    layout: bindGroupLayout, // Updated Line

    entries: [{
      binding: 0,
      resource: { buffer: angleOutStorage }
    }, {
      binding: 1, // New Entry
      resource: { buffer: angleStorage }
    }],
  }),
];
		const pipelineLayout = device.createPipelineLayout({
  label: "Cell Pipeline Layout",
  bindGroupLayouts: [ bindGroupLayout ],
});

				const cellPipeline = device.createRenderPipeline({
					label: "Cell pipeline",
					layout: pipelineLayout,
					vertex: {
						module: cellShaderModule,
						entryPoint: "vertexMain",
						buffers: [vertexBufferLayout]
					},
					fragment: {
						module: cellShaderModule,
						entryPoint: "fragmentMain",
						targets: [{
							format: canvasFormat
						}]
					}
				});
				const UPDATE_INTERVAL = 1000/60; // Update every 200ms (5 times/sec)
let step = 0; // Track how many simulation steps have been run

const simulationPipeline = device.createComputePipeline({
  label: "Simulation pipeline",
  layout: pipelineLayout,
  compute: {
    module: simulationShaderModule,
    entryPoint: "computeMain",
  }
});

function updateGrid() {
		step++; // Increment the step count
		
		// Start a render pass 
		const encoder = device.createCommandEncoder();
		const computePass = encoder.beginComputePass();

		

	computePass.setPipeline(simulationPipeline);
	computePass.setBindGroup(0, bindGroups[step % 2]);

	const workgroupCount = 1;
	computePass.dispatchWorkgroups(workgroupCount, workgroupCount);

	computePass.end();
		const pass = encoder.beginRenderPass({
			colorAttachments: [{
				view: context.getCurrentTexture().createView(),
				loadOp: "clear",
				clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },
				storeOp: "store",
			}]
		});

		// Draw the grid.
		pass.setPipeline(cellPipeline);
		pass.setBindGroup(0, bindGroups[step % 2]); // Updated!
		pass.setVertexBuffer(0, vertexBuffer);
		pass.draw(vertices.length / 2, 9);

		// End the render pass and submit the command buffer
		pass.end();
		device.queue.submit([encoder.finish()]);
	}

	// Schedule updateGrid() to run repeatedly
	setInterval(updateGrid, UPDATE_INTERVAL);
  
    </script>
  </body>
</html>