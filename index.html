<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
				const adapter = await navigator.gpu?.requestAdapter();
				const device = await adapter?.requestDevice();
				if (!device) {
					throw new Error()
				}

				// Get a WebGPU context from the canvas and configure it
				const canvas = document.querySelector('canvas');
				const context = canvas.getContext('webgpu');
				const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device: device,
					format: canvasFormat,
				})
				const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device,
					format: presentationFormat,
				});
				/*
				const vertices = new Float32Array([
				//   X,    Y,
					-0.8, -0.8, // Triangle 1 (Blue)
					0.8, -0.8,
					0.8,  0.8,

					-0.8, -0.8, // Triangle 2 (Red)
					0.8,  0.8,
					-0.8,  0.8,
				]);*/

				const SECTORS = 10;

				const SUBDIVISIONS = 5;
				
				const vertices = new Float32Array(SUBDIVISIONS*6)
				/*
				for(let i = 0; i < SUBDIVISIONS; i++){
					vertices[6*i] = 0;
					vertices[6*i+1] = 0;
					vertices[6*i+2] = Math.cos(2*Math.PI/SUBDIVISIONS*i);
					vertices[6*i+3] = Math.sin(2*Math.PI/SUBDIVISIONS*i);
					vertices[6*i+4] = Math.cos(2*Math.PI/SUBDIVISIONS*(i+1));
					vertices[6*i+5] = Math.sin(2*Math.PI/SUBDIVISIONS*(i+1));
				}*/

				const vertexBuffer = device.createBuffer({
				label: "Cell vertices",
				size: vertices.byteLength,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
			});
			device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
				
			const vertexBufferLayout = {
				arrayStride: 8,
				attributes: [{
					format: "float32x2",
					offset: 0,
					shaderLocation: 0, // Position, see vertex shader
				}],
			};
			const cellShaderModule = device.createShaderModule({
					label: 'Cell shader',
					code: `
					struct VertexInput {
					@location(0) pos: vec2f,
					@builtin(instance_index) instance: u32,
					@builtin(vertex_index) vertexIndex : u32
				};
				@group(0) @binding(0) var<storage> angle: array<f32>;

				struct VertexOutput {
					@builtin(position) pos: vec4f,
					@location(0) @interpolate(flat) fi: f32,
				};
				struct FragInput {
					@builtin(position) pos: vec4f,
					@location(0) @interpolate(flat) fi: f32,
				};
						@vertex
						fn vertexMain(input: VertexInput) -> VertexOutput  {
							
							var output: VertexOutput;
							let index = f32(input.vertexIndex);
							let i = f32(input.instance);
							let d = floor(index / 3);
							if(input.vertexIndex % 3 == 0){
								output.pos = vec4f(0, 0, 0, 1);
							} else if (input.vertexIndex % 3 == 1){
								output.pos = vec4f(cos(2*3.14/100*i+d*2*3.14/100/5+angle[0]), sin(2*3.14/100*i+d*2*3.14/100/5+angle[0]), 0, 1);
							} else {
								output.pos = vec4f(cos(2*3.14/100*i+(d+1)*2*3.14/100/5+angle[0]), sin(2*3.14/100*i+(d+1)*2*3.14/100/5+angle[0]), 0, 1);
							}
							output.fi = i;
							return output;
						}

						@fragment
						fn fragmentMain(input: FragInput) -> @location(0) vec4f {
							return vec4f(input.fi % 4 / 4,input.fi % 100 / 100, input.fi % 13, 1);
						}
					`
				});
				const WORKGROUP_SIZE = 1;

				// Create an array representing the active state of each cell.
			const angle = new Float32Array(1);
			
			angle[0] = 0;

[]			
			// Create a storage buffer to hold the cell state.
			const angleStorage = device.createBuffer({
				label: "Cell State",
				size: angle.byteLength,
				usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
			});
			const angle_out = new Float32Array(1);
			
			angle_out[0] = 0;

			
			// Create a storage buffer to hold the cell state.
			const angleOutStorage = device.createBuffer({
				label: "Cell State",
				size: angle_out.byteLength,
				usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
			});
			device.queue.writeBuffer(angleStorage, 0, angle);
			device.queue.writeBuffer(angleOutStorage, 0, angle_out)
				const simulationShaderModule = device.createShaderModule({
					label: "Game of Life simulation shader",
					code: `
					@group(0) @binding(0) var<storage> angle: array<f32>;
					@group(0) @binding(1) var<storage, read_write> angle_out: array<f32>;
						@compute
						@workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE})
						fn computeMain() {
							angle_out[0] = angle[0]+3.14/100;
						}`
				});


				// Create the bind group layout and pipeline layout.
		const bindGroupLayout = device.createBindGroupLayout({
			label: "Cell Bind Group Layout",
			entries: [{
				binding: 0,
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
			buffer: { type: "read-only-storage"} // Cell state input buffer
			}, {
				binding: 1,
				visibility: GPUShaderStage.COMPUTE,
				buffer: { type: "storage"} // Cell state output buffer
			}]
		});
		const bindGroups = [
  device.createBindGroup({
    label: "Cell renderer bind group A",
    layout: bindGroupLayout, // Updated Line
    entries: [{
      binding: 0,
      resource: { buffer: angleStorage }
    }, {
      binding: 1, // New Entry
      resource: { buffer: angleOutStorage }
    }],
  }),
  device.createBindGroup({
    label: "Cell renderer bind group B",
    layout: bindGroupLayout, // Updated Line

    entries: [{
      binding: 0,
      resource: { buffer: angleOutStorage }
    }, {
      binding: 1, // New Entry
      resource: { buffer: angleStorage }
    }],
  }),
];
		const pipelineLayout = device.createPipelineLayout({
  label: "Cell Pipeline Layout",
  bindGroupLayouts: [ bindGroupLayout ],
});

				const cellPipeline = device.createRenderPipeline({
					label: "Cell pipeline",
					layout: pipelineLayout,
					vertex: {
						module: cellShaderModule,
						entryPoint: "vertexMain",
						buffers: [vertexBufferLayout]
					},
					fragment: {
						module: cellShaderModule,
						entryPoint: "fragmentMain",
						targets: [{
							format: canvasFormat
						}]
					}
				});
				const UPDATE_INTERVAL = 1000/60; // Update every 200ms (5 times/sec)
let step = 0; // Track how many simulation steps have been run

const simulationPipeline = device.createComputePipeline({
  label: "Simulation pipeline",
  layout: pipelineLayout,
  compute: {
    module: simulationShaderModule,
    entryPoint: "computeMain",
  }
});

function updateGrid() {
		step++; // Increment the step count
		
		// Start a render pass 
		const encoder = device.createCommandEncoder();
		const computePass = encoder.beginComputePass();

		

	computePass.setPipeline(simulationPipeline);
	computePass.setBindGroup(0, bindGroups[step % 2]);

	const workgroupCount = 1;
	computePass.dispatchWorkgroups(workgroupCount, workgroupCount);

	computePass.end();
		const pass = encoder.beginRenderPass({
			colorAttachments: [{
				view: context.getCurrentTexture().createView(),
				loadOp: "clear",
				clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },
				storeOp: "store",
			}]
		});

		// Draw the grid.
		pass.setPipeline(cellPipeline);
		pass.setBindGroup(0, bindGroups[step % 2]); // Updated!
		pass.setVertexBuffer(0, vertexBuffer);
		pass.draw(vertices.length / 2, 100);

		// End the render pass and submit the command buffer
		pass.end();
		device.queue.submit([encoder.finish()]);
	}

	// Schedule updateGrid() to run repeatedly
	setInterval(updateGrid, UPDATE_INTERVAL);
  
    </script>
  </body>
</html>