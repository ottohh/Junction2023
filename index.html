<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
				const adapter = await navigator.gpu?.requestAdapter();
				const device = await adapter?.requestDevice();
				if (!device) {
					throw new Error()
				}

				// Get a WebGPU context from the canvas and configure it
				const canvas = document.querySelector('canvas');
				const context = canvas.getContext('webgpu');
				const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device: device,
					format: canvasFormat,
				})
				const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
				context.configure({
					device,
					format: presentationFormat,
				});
								
				const vertices = new Float32Array([
				//   X,    Y,
					0,  0, // Triangle 1 (Blue)
					1,  1,
					0,  1,

					0, 0, // Triangle 2 (Red)
					1,  0,
					1,  1,
				]);

				const vertexBuffer = device.createBuffer({
				label: "Cell vertices",
				size: vertices.byteLength,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
			});


			device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
				
			const vertexBufferLayout = {
				arrayStride: 8,
				attributes: [{
					format: "float32x2",
					offset: 0,
					shaderLocation: 0, // Position, see vertex shader
				}],
			};
				const BALL_COUNT = 100;
			const cellShaderModule = device.createShaderModule({
					label: 'Cell shader',
					code: `
					struct VertexInput {
					@location(0) pos: vec2f,
					@builtin(instance_index) instance: u32,
					@builtin(vertex_index) vertexIndex : u32
				};
				@group(0) @binding(0) var<storage> ballStateIn: array<f32>;
				@group(0) @binding(2) var<storage> ballRadius: array<f32, ${BALL_COUNT}>;
					

				struct VertexOutput {
					@builtin(position) pos: vec4f,
					@location(0) position: vec2f,
					@location(1) radius: f32,
					@location(2) instance: f32,
				};
				struct FragInput {
					@builtin(position) pos: vec4f,
					@location(0) position: vec2f,
					@location(1) radius: f32,
					@location(2) instance: f32,
				};
						@vertex
						fn vertexMain(input: VertexInput) -> VertexOutput  {
							let pos1 = vec2f(ballStateIn[4*input.instance], ballStateIn[4*input.instance+1]);
							let radius = ballRadius[input.instance] / 2;
							let anotherpos = vec2f(input.pos.x*radius - radius / 2, input.pos.y*radius - radius / 2);
							var output: VertexOutput;
							output.pos = vec4f((anotherpos+pos1), 0, 1);
							output.position = pos1;
							output.radius = radius;
							output.instance = f32(input.instance);
							return output;
						}


						@fragment
						fn fragmentMain(input: FragInput) -> @location(0) vec4f {
							let vec = vec2f(input.pos.x/ 512 - 0.5, (input.pos.y / 512 - 0.5)*-1)* 2 - input.position;
							let dist = vec.x*vec.x+vec.y*vec.y;
							if(dist > (input.radius/2)*(input.radius/2)) {
							  discard;
							}
							return vec4f(1, 1, 1, 1);
						}
					`
				});
				const WORKGROUP_SIZE = 64;
				// Array representing the x,y coordinates and  x y speed vector of balls

				const ballStateArray = new Float32Array(BALL_COUNT*4);
				const ballRadiusArray = new Float32Array(BALL_COUNT);
				for(let i = 0; i < BALL_COUNT*4; i++){
					ballStateArray[i] = (Math.random() * 2 - 1)/2;
					ballRadiusArray[i] = (Math.random()+0.0001)/50
				}



				// Create two storage buffers to hold the cell state.
				const ballStateStorage = [
					device.createBuffer({
						label: "Ball State A",
						size: ballStateArray.byteLength,
						usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					}),
					device.createBuffer({
						label: "Ball State B",
						size: ballStateArray.byteLength,
						usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					})
				];
				const radiusStorage = 
					device.createBuffer({
						size: ballRadiusArray.byteLength,
						usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					})

				device.queue.writeBuffer(radiusStorage, 0, ballRadiusArray)



				device.queue.writeBuffer(ballStateStorage[1], 0, ballStateArray);
				// Set each cell to a random state, then copy the JavaScript array into
				// the storage buffer.

device.queue.writeBuffer(ballStateStorage[0], 0, ballStateArray);

const G = 0.1;
const UPDATE_INTERVAL = 1000/60;
const dt = UPDATE_INTERVAL/1000;
const simulationShaderModule = device.createShaderModule({
        label: "Life simulation shader",
        code: 
				`
          @group(0) @binding(0) var<storage> ballStateIn: array<f32>;
          @group(0) @binding(1) var<storage, read_write> ballStateOut: array<f32>;
				  @group(0) @binding(2) var<storage> ballRadius: array<f32, ${BALL_COUNT}>;
          @compute @workgroup_size(${WORKGROUP_SIZE})
          fn computeMain(@builtin(global_invocation_id) cell: vec3u) {
            // Determine how many active neighbors this cell has.
            var ballNumber = cell.x;
            var BALL_COUNT = u32(${BALL_COUNT});
						ballStateOut[ballNumber*4+0] = ballStateIn[ballNumber*4+0];
						ballStateOut[ballNumber*4+1] = ballStateIn[ballNumber*4+1];
						ballStateOut[ballNumber*4+2] = ballStateIn[ballNumber*4+2];
						ballStateOut[ballNumber*4+3] = ballStateIn[ballNumber*4+3];

						let pos =  vec2f(ballStateIn[ballNumber*4], ballStateIn[ballNumber*4+1]);

            for(var i = u32(0);i<BALL_COUNT;i++)
            {
                //We dont want to calculate the force with the ball itself
                if(i==ballNumber){continue;}

								let r = vec2f(ballStateIn[i*4], ballStateIn[i*4+1]) - pos;

								var r_squared = r.x*r.x+r.y*r.y;
								if(r_squared < 0.001) {r_squared = 0.001;}
								let num = ${G}/r_squared;

								let acc = normalize(r) * num * ${dt} * ballRadius[i];

								ballStateOut[ballNumber*4+2] += acc.x;
								ballStateOut[ballNumber*4+3] += acc.y;
							}
							var newX = ballStateOut[ballNumber*4] + ballStateOut[ballNumber*4+2] * ${dt};
							var newY = ballStateOut[ballNumber*4+1] + ballStateOut[ballNumber*4+3] * ${dt};
							if(newX+ballRadius[ballNumber]>=1 || newX- ballRadius[ballNumber]<=-1){
								ballStateOut[ballNumber*4+2] = -1*ballStateOut[ballNumber*4+2];
							}
							if(newY+ballRadius[ballNumber]>=1 || newY- ballRadius[ballNumber]<=-1){
								ballStateOut[ballNumber*4+3] = -1*ballStateOut[ballNumber*4+3];
							}
							ballStateOut[ballNumber*4] += ballStateOut[ballNumber*4+2] * ${dt};
							ballStateOut[ballNumber*4+1] += ballStateOut[ballNumber*4+3] * ${dt};	
          }
					
					`
        
      });


				const bindGroupLayout = device.createBindGroupLayout({
        label: "Cell Bind Group Layout",
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
          buffer: { type: "read-only-storage"} // balls state input buffer
        },{
          binding: 1,
          visibility: GPUShaderStage.COMPUTE,
          buffer: { type: "storage"} // Ball state output buffer 
        }, {
					binding: 2,
					visibility: GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX,
					buffer: { type: "read-only-storage" }
				}]
      });
			const bindGroups = [
        device.createBindGroup({
          label: "Cell renderer bind group A with cellSpeeds",
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: ballStateStorage[0] }

          }, {
            binding: 1,
            resource: { buffer: ballStateStorage[1] }

          },
					{
						binding: 2,
						resource: { buffer: radiusStorage }
					}]
        }),

        device.createBindGroup({
          label: "Cell renderer bind group B with cellSpeeds",
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: ballStateStorage[1] }

          }, {
            binding: 1,
            resource: { buffer: ballStateStorage[0] }

          },
					{
						binding: 2,
						resource: { buffer: radiusStorage }
					}],
        }),
      ];
		const pipelineLayout = device.createPipelineLayout({
  label: "Cell Pipeline Layout",
  bindGroupLayouts: [ bindGroupLayout ],
});

				const cellPipeline = device.createRenderPipeline({
					label: "Cell pipeline",
					layout: pipelineLayout,
					vertex: {
						module: cellShaderModule,
						entryPoint: "vertexMain",
						buffers: [vertexBufferLayout]
					},
					fragment: {
						module: cellShaderModule,
						entryPoint: "fragmentMain",
						targets: [{
							format: canvasFormat
						}]
					}
				});
let step = 0; // Track how many simulation steps have been run

const simulationPipeline = device.createComputePipeline({
  label: "Simulation pipeline",
  layout: pipelineLayout,
  compute: {
    module: simulationShaderModule,
    entryPoint: "computeMain",
  }
});

function updateGrid() {
		step++; // Increment the step count
		
		// Start a render pass 
		const encoder = device.createCommandEncoder();
		const computePass = encoder.beginComputePass();

		

	computePass.setPipeline(simulationPipeline);
	computePass.setBindGroup(0, bindGroups[step % 2]);

	const workgroupCount = Math.ceil(BALL_COUNT / WORKGROUP_SIZE);
	computePass.dispatchWorkgroups(workgroupCount, 1);

	computePass.end();
		const pass = encoder.beginRenderPass({
			colorAttachments: [{
				view: context.getCurrentTexture().createView(),
				loadOp: "clear",
				clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },
				storeOp: "store",
			}]
		});

		// Draw the grid.
		pass.setPipeline(cellPipeline);
		pass.setBindGroup(0, bindGroups[step % 2]); // Updated!
		pass.setVertexBuffer(0, vertexBuffer);
		pass.draw(vertices.length / 2, BALL_COUNT);

		// End the render pass and submit the command buffer
		pass.end();
		device.queue.submit([encoder.finish()]);
	}

	// Schedule updateGrid() to run repeatedly
	setInterval(updateGrid, UPDATE_INTERVAL);
  
    </script>
  </body>
</html>